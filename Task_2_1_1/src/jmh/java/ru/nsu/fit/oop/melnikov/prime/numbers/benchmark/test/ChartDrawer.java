package ru.nsu.fit.oop.melnikov.prime.numbers.benchmark.test;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.knowm.xchart.BitmapEncoder;
import org.knowm.xchart.XYChart;
import org.knowm.xchart.XYChartBuilder;

/**
 * Class that draws a chart of benchmark tests using generated by jmh .json-file.
 */
public class ChartDrawer {

  public static void main(String[] args) {

    ObjectMapper mapper = new ObjectMapper();

    JsonNode jsonNodeRoot;
    try {
      jsonNodeRoot = mapper.readTree(
          new File("results.json")
      );
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    Map<String, Map<Integer, Double>> charts = new HashMap<>();
    Map<String, Map<String, Map<Integer, Double>>> threadCharts = new HashMap<>();

    for (JsonNode node : jsonNodeRoot) {
      String test = node.get("benchmark").asText();
      test = test.substring(test.lastIndexOf(".") + 1);

      if (node.path("params").has("threadCount")) {

        int threadCount = node.path("params").get("threadCount").asInt();
        int size = node.path("params").get("size").asInt();
        String group = test;
        test += threadCount;

        if (!threadCharts.containsKey(group)) {
          threadCharts.put(group, new HashMap<>());
        }
        Map<String, Map<Integer, Double>> testPool = threadCharts.get(group);

        if (!testPool.containsKey(test)) {
          threadCharts.get(group).put(test, new HashMap<>());
        }

        testPool.get(test).put(size ,node.path("primaryMetric").get("score").asDouble());

        if(threadCount != Runtime.getRuntime().availableProcessors()) {
          continue;
        }

      }

      if (!charts.containsKey(test)) {
        charts.put(test, new HashMap<>());
      }
      charts.get(test).put(node.path("params").get("size").asInt(),
          node.path("primaryMetric").get("score").asDouble());
    }

    makeChart(charts, "Benchmark tests");
    for(Map.Entry<String, Map<String, Map<Integer, Double>>> entry : threadCharts.entrySet()) {
      makeChart(entry.getValue(), entry.getKey());
    }

  }

  private static void makeChart(Map<String, Map<Integer, Double>> charts, String chartName) {
    XYChart chart = new XYChartBuilder().title(chartName).xAxisTitle("array size")
        .yAxisTitle("score, ops/s").build();
    chart.getStyler().setXAxisLogarithmic(true);
    chart.getStyler().setYAxisLogarithmic(true);

    for (String testName : charts.keySet()) {
      List<Integer> sizeData = charts.get(testName).keySet().stream().sorted().toList();
      List<Double> scoreData = sizeData.stream().map(x -> charts.get(testName).get(x)).toList();
      chart.addSeries(testName, sizeData, scoreData);
    }

    try {
      BitmapEncoder.saveBitmapWithDPI(
          chart,
          "./"+ chartName + " result.png",
          BitmapEncoder.BitmapFormat.PNG,
          300
      );
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

}
